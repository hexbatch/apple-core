new set operations


Add push and pop and queue and dequeue to set operations: tokens or set relationships can be done this way.
Events can decide to not do this.

 When a token is applied, and its pushed or queued,
    it's added to the set, and its given an ordering attribute, the order depends on the other order values of the other tokens, and what the operation is doing.
    highest ordering for push, and lowest ordering for queue
    The ordering can get negative, the default is 0 in a set that has no ordering.
    tokens that are queued can be popped, and similar for the other way

 When a token is applied, and its popped or dequeued then the token with the appropriate ordering is removed from the set,
 highest ordering for pop, and lowest ordering for queue

When a set relationship is pushed or queued, the set is made into a child of the set holding it (so its token is still put in the set, but its in a child relationship state)
This allows ordering of children.

When a set relationship is dequeued or popped, then similar

instead of children, can do this with links

-------------------------------------------

json Arrays that are ordered can be made by using the agg operations

------------------------------------------

Iteration:

There can be a cursor made (a filter with an attribute that has value of number representing the current order)
Applying this cursor to a set gets tokens or children in order (can choose)
Can use this iterator as a filter in any set operation
Same iterator can be used on several different sets, and can be reset at any time. If not reset and the newer set has no position of that kind, then nothing returned


Ordering in general:
    It can happen that some tokens have the same order.
    Same order rank will cause the above operations to skip all but one randomly chosen

There is a set operation to reset order so that all have a different order, same order things before will be next to each other in the new ordering
There is set operation to remove all ordering
Set operations to create, reset iterators

Iterators can allow loops to happen, with each api call.

A type of iterator does not keep track of the current index via its attribute, but assigns a current attribute to the tokens. This makes the current sticky across many different iterators,
but need permissions to the tokens to do that, and any token that is not allowing this attribute will be skipped, so is a great way to iterate writable tokens