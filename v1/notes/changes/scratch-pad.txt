Possible to make a filter out of attributes on a token?
Requirements should allow "or" and "and" grouping. Is this done by have a relationship of sets,
each token in the set is a requirement, and each layer of children is an "or"?
have all the requirement attributes be descended by some system defined thing.
attributes for ordering also.

Mutuals allow mapping values onto these attributes

Can this replace the requirements data structure? It makes it more fluid

---------------------
Add push and pop and queue and dequeue to set operations: children in sets should have optional ordering (ordering is same attribute as above)
the above can also be done to tokens going into a set. Put a live category attribute on a token, and give it an order attribute. Or define which those two attributes are in the api call,
same with sets.
----------------------
tokens in a set can be organized by the order attribute, its possible to do arrays
----------------------
by setting a "current" attribute, and the ordering, can do loops getting a token from a set, marking it current.
This should be a set api also. This provides a cursor to track progress and do iterations with set operations.
Filters can be marked this way, to iterate through filters also: when giving a set as a filter,
 any set inside of it that has the attributes for filtering or ordering results and is marked current is used

Sets, having tokens with attributes inside that filter, can be parts of filters. Sets in a mutual group can be a filter.
Can do any mutual operation to regenerate a filter.

Filter, or part of a filter, can be linked to a target set to put the tokens, this can be done via a token with that attribute and the value is the set, or it can be done via set links
and put an attribute on that link
------
set apis should be organized by those that can produce events, and those that do not. But, I think all set operations can produce events?

---------------------------------
Live attributes that are dynamically added can be added in only a set context or for the token everywhere.
set context can also be shared attributes in sets that contain the token, and can be a mutual group of sets that contain the token
Mutual groups should have their own context for token changes, the mutual operations should allow these to be sticky or not when making new mutual groups out of older ones
  Non sticky operations throw out any mutual context of token changes

