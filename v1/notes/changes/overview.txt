

Core:



    Attributes:
        they can be const: this works if they are not set by action, remote or script
        they can be static: the value is shared on the token type itself (see type live attributes)
            static attributes can have remotes and scripts, but not actions (no token type actions)
                These remotes can be configured to be called only once, on first reading, and this enforces a type of const after that
        Can be both static and const
        Add Final status to forbid any usage of this attribute as a parent
        Add human status, default true, to selectively hide attributes in api calls if the human filter is on.
        On the type of value, add in specific id categories: token, type, attribute, search, script, remote, action, bounds
        When a token is also a set, a group, or represents a user, it has an attribute showing that. A filter can filter api types with this attribute set to that type
        Attribute values has a microsecond time stamp of when last written to, or turned on
        When live attributes are added to a token,  record the user that added them.


    Remotes:
        Remotes can be type pause, allowing a user to enter remote response via api.
         When an api pauses, the waiting remote can be filled in by the caller, even if they do not make the remote.
         see api-execution

    Scripts and Remotes:
        Now can decide add live attributes, via the return info the system will attach the live.
            * Scripts adding these will only be able to if events reacting allow this
            * Can only apply live or remove live if the action's attribute is in the same context (a token type added at design, a live for all the token, or just in a set context)
        Can set token coordinates.
        Can set the token time to live attribute to 0, or add that, and the token will be removed

    Types:
            token types can have live attributes that apply to all the tokens (but not the type itself)
                * changes for all tokens and can overwrite inherited on the tokens
                * live attributes put on the tokens can overwrite an attribute already there, by design or later action.
                * no limit to how many live attributes that overwrite the earlier one. They stack by when applied.
            need discussion about attributes able to overwrite their parents. If I have A inherits from B, and C inherits from B
                if a token has B, and I add a live of A, then that overwrites the B. However if I add C, then that does not overwrite B (B is not a child of A)
            scripts and remotes should have their storage as live token level attributes,
                but not sure how that works with the attribute value being a script and not the state for the script (remote too)
            Add Final status to forbid any usage of this type as a parent
            Add human status, default true, to selectively hide tokens made from this type in api calls if the human filter is on
            Can add parent to type as long as at least one attribute is readable
            Can add attribute to type or live when attribute is both readable and writable. Do not have to own attribute (this causes some changes in sketched out ntoes)

    Requirements:
        Now done via sets see filters.txt

    Events:
        Can send custom event, one that inherits from the custom even attribute, to any one token per api call to send event.
        Add event to a set that is used to decide if an api operation can be done. This puts more control over automated api calls using decisions to js and remotes.
        Can have a read event. Cycles prevented by new api mechanisms
        * Can have an event for applying a live type on a type, for all tokens, as well as on the token, as well as on the token in a set context, can have one event for all three also
        * Same for removing

    Set:
        Set tokens are seen as normal tokens unless in a set which has them as a child or link or parent.
            * "any token can make a set and still be a regular token"
        Sets that have a location set and a map bounds can only accept tokens that are in its bounds, or do not have a location set for them.
        Set parents are in the child as a token, just as the child is in the parent as a token
           Removing either breaks the parent child relationship
           Relationships for sets are still also defined by special defined attribute
        Can filter its content via one or more path boundaries
        Sets can have an attribute to mark them as a view


    Set operations:

        set operations can use the human filter
        set operations use the pre-filter to decide to do the set operation
        get common tokens from a group of sets, put them in a new set. Can do opposite too: remove common tokens from groups
        Aggregation operations: Use group operations on selected attributes in a set to calculate one value which then is written to a target token attribute as a live attribute on the token.
        Aggregation operations take a set of tokens, can do operations on it to reduce this to a single value. The operation can be filtered
        Any api call can provide a token or attribute using an iterator from a set (current token), can filter attribute(s)  to use.

                set operations can have some logic now, optional set and filter to put in to decide to do the set operation in the api call.
                There has to be at least one token in the set that gets matched by the filter. This is not the filter to do the operation with, but to decide to do it or not.
        see new-set-operations for push and iterations


    Mutual sets:
        Two or more sets that have one or more exact same tokens in their collections are connected together by these tokens, but not in a linked relationship
        These can be many sets bound together in different patterns and geometries. Mutually bound sets can also be connected via parent child relationships and links.
        Can select these relations into a set known as a view, which only contains mutually connected set systems (all the sets have to be directly or indirectly sharing the same tokens).


    Mutual operations:
        Aggregation operations: can do aggregation operations on mutual sets. The operations can be written to a single attribute on a target token
            Agg op to combine ordered tokens in a set to json array
        Strong attribute operations
        Superimposed operations.
        Operations on mutual sets.
        Selection on mutuals, this can be custom, see below.
        Mutual set selection: different ways to select mutual sets into a view
            When selecting, can put limits of how many mutual distance, and limit the mutual token types.
        Able to make macros. Macros made from push and pop of other operations. Only mutual operations allowed because they do no events
            Macros can be run by actions (not using script or remote, just set the macro id)
        Can register custom macros in the core, not by users, but by plugin. For instance macros to select via topology and area charges on mutual entanglements.

    Search:
        Search results of sets should list its parent.
        New Search operations and search modifiers






