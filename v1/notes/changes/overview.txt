Core:


    Types:
            token types can have live attributes that apply to all the tokens (but not the type itself)
                * changes for all tokens and can overwrite inherited on the tokens
                * live attributes put on the tokens can overwrite an attribute already there, by design or later action.
                * no limit to how many live attributes that overwrite the earlier one. They stack by when applied.
            need discussion about attributes able to overwrite their parents. If I have A inherits from B, and C inherits from B
                if a token has B, and I add a live of A, then that overwrites the B. However if I add C, then that does not overwrite B (B is not a child of A)
            scripts and remotes should have their storage as live token level attributes,
                but not sure how that works with the attribute value being a script and not the state for the script (remote too)
            Add Final status to forbid any usage of this type as a parent
            Add human status, default true, to selectively hide tokens made from this type in api calls if the human filter is on
            Can add parent to type as long as at least one attribute is readable
            Can add attribute to type or live when attribute is both readable and writable. Do not have to own attribute (this causes some changes in sketched out ntoes)


-------------------

    Live tokens:
        * When live attributes are added to a token,  record the user that added them.
        * Attribute values has a microsecond time stamp of when last written to, or turned on
        * Live attributes can be added to a type, and that is used only for the tokens created by that type
-------------------

    Events:
        * Can send custom event, one that inherits from the custom even attribute, to any one token per api call to send event.
        * Can have a read event. Cycles prevented by new api mechanisms

        * Can have an event for applying or removing a live attribute, on the type level, for all tokens.
          * same event can be on the per token
          * same can be for live added or removed in a set context (the live cannot be seen outside that set)
          * can have one event for all three also

-------------------


    Set:
        Set tokens are seen as normal tokens unless in a set which has them as a child or link or parent.
            * "any token can make a set and still be a regular token"

        Set parents are in the child as a token, just as the child is in the parent as a token
           Removing either breaks the parent child relationship
           Relationships for sets are still also defined by special defined attribute

        Can filter its content via one or more path boundaries



-------------------

    Set operations:

        set operations can use the human filter
        set operations use the pre-filter to decide to do the set operation
        get common tokens from a group of sets, put them in a new set. Can do opposite too: remove common tokens from groups
        starting with a token or set of tokens, and a target set, find the mutual sets shared with these tokens.
            can omit the token(s) and just provide a set, and will find all the mutual sets to it


-------------------

    Search:
        Search results of sets should list its parent.
        New Search operations and search modifiers.
        Searches can select on intersections of bounds (to select those that do or do not) for tokens inside the same set


        ---------

        @mutual()

        returns sets that share the same tokens in this path

        can combine with @set() or other, when finding the @set, then will use that set token

        @set and @mutual can have an upper or lower number for members or connected sets
        @set(.what)[2,5] between 2 and 5 different tokens with attribute .what
        can also do [2,] for lower bounds and [,5] for upper

        will give paginated if too big

        ------------

        nested @ stuff
        @mutual(@child(@user('will')))

        ----------------

        Ancestry modifiers

        ~ means descended from but not including

        = means exact token no descendants

        =#cats.furry   -- matches cats token only
        ~#cats.furry   -- only descendants of this token

        use in attributes and tokens
        ---------------------
        multiple things
        , comma separates  use in @set and @mutual and multiple inheritance

        #catty@set(.long, =#tickle)  gets sets defined by catty or descenents which contain both tokens with long attribute and exact match for tickle

        @mutual(.run, .go) gets interconnecting sets that share one or more tokens which have the attributes of .run and .go


        (#runs, =#running).poking  gets a token that inherits from both runs (and descendants) and running exact

        --------------------------------
        @child(.who) selects any child that is a set that contains the .who attribute
        @child(.who).what  above but the child token defining the set must have a who attribute
        ------------------------

        .bookmark @child(@mutual(.gosh) )#go  a token defining a set must be a child of another set that has a bookmark attribute,
        and contain at least two set tokens who have a mutual token of attribute .goth

        -----------------
        @view is shorthand for @set(@mutual)






