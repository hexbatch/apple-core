

Core:



    Attributes:
        * they can be const: this works if they are not set by action, remote or script
        * they can be static: the value is shared on the token type itself (see type live attributes)
            static attributes can have remotes and scripts, but not actions (no token type actions)
                These remotes can be configured to be called only once, on first reading, and this enforces a type of const after that
          * Can be both static and const
        * Add Final status to forbid any usage of this attribute as a parent
        * Add human status, default true, to selectively hide attributes in api calls if the human filter is on.
        * On the type of value, add in specific id categories: token, type, attribute, search, script, remote, action, bounds
        * When a token is also a set, a group, or represents a user, it has an attribute showing that. A filter can filter api types with this attribute set to that type



            Summary: const , static, final, human, better value types for ids, standard attributes for token roles

-------------------

    Scripts and Remotes:
        Now can decide add live attributes, via the return info the system will attach the live.
            * Scripts adding these will only be able to if events reacting allow this
            * Can only apply live or remove live if the action's attribute is in the same context (a token type added at design, a live for all the token, or just in a set context)
        Can set token coordinates.
        Can set the token time to live attribute to 0, or add that, and the token will be removed

-------------------

    Types:
            token types can have live attributes that apply to all the tokens (but not the type itself)
                * changes for all tokens and can overwrite inherited on the tokens
                * live attributes put on the tokens can overwrite an attribute already there, by design or later action.
                * no limit to how many live attributes that overwrite the earlier one. They stack by when applied.
            need discussion about attributes able to overwrite their parents. If I have A inherits from B, and C inherits from B
                if a token has B, and I add a live of A, then that overwrites the B. However if I add C, then that does not overwrite B (B is not a child of A)
            scripts and remotes should have their storage as live token level attributes,
                but not sure how that works with the attribute value being a script and not the state for the script (remote too)
            Add Final status to forbid any usage of this type as a parent
            Add human status, default true, to selectively hide tokens made from this type in api calls if the human filter is on
            Can add parent to type as long as at least one attribute is readable
            Can add attribute to type or live when attribute is both readable and writable. Do not have to own attribute (this causes some changes in sketched out ntoes)
            New user group for ghosts listening to the token events, and filter which events

-------------------

    Live tokens:
        * When live attributes are added to a token,  record the user that added them.
        * Ghost attributes
        * Attribute values has a microsecond time stamp of when last written to, or turned on
        * ghost status


-------------------

    Requirements:
        Now done via sets see filters.txt


-------------------

    Events:
        * Can send custom event, one that inherits from the custom even attribute, to any one token per api call to send event.

        * Can have a read event. Cycles prevented by new api mechanisms

        * Can have an event for applying or removing a live attribute, on the type level, for all tokens.
          * same event can be on the per token
          * same can be for live added or removed in a set context (the live cannot be seen outside that set)
          * can have one event for all three also


        * More events in interfaces

        * Need events to mirror tokens: global-attribute-on-write global-attribute-on-read. These actions can be added to the type itself as live attributes
          * the writes on the global attribute context are trigger global-attribute-on-write, and a single action could handle all the attributes it wants
          * reads on global attribute context (stored in the type) trigger the global-attribute-on-read
          * action not responding to event means it's not handled by it, and go to next layer of getting or setting info
          * there can be multiple actions listening to these events

-------------------


    Set:
        Set tokens are seen as normal tokens unless in a set which has them as a child or link or parent.
            * "any token can make a set and still be a regular token"
        Sets that have a location set and a map bounds can only accept tokens that are in its bounds, or do not have a location set for them.
        Set parents are in the child as a token, just as the child is in the parent as a token
           Removing either breaks the parent child relationship
           Relationships for sets are still also defined by special defined attribute
        Can filter its content via one or more path boundaries
        Sets can have an attribute to mark them as a view


-------------------

    Set operations:

        set operations can use the human filter
        set operations use the pre-filter to decide to do the set operation
        get common tokens from a group of sets, put them in a new set. Can do opposite too: remove common tokens from groups
        Aggregation operations: Use group operations on selected attributes in a set to calculate one value which then is written to a target token attribute as a live attribute on the token.
        Aggregation operations take a set of tokens, can do operations on it to reduce this to a single value. The operation can be filtered
        Any api call can provide a token or attribute using an iterator from a set (current token), can filter attribute(s)  to use.

                set operations can have some logic now, optional set and filter to put in to decide to do the set operation in the api call.
                There has to be at least one token in the set that gets matched by the filter. This is not the filter to do the operation with, but to decide to do it or not.
        see new-set-operations for push and iterations


-------------------

    Mutual sets:
        Two or more sets that have one or more exact same tokens in their collections are connected together by these tokens, but not in a linked relationship
        These can be many sets bound together in different patterns and geometries. Mutually bound sets can also be connected via parent child relationships and links.
        Can select these relations into a set known as a view, which only contains mutually connected set systems (all the sets have to be directly or indirectly sharing the same tokens).



-------------------


    Mutual operations:
        Aggregation operations: can do aggregation operations on mutual sets. The operations can be written to a single attribute on a target token
            Agg op to combine ordered tokens in a set to json array
        Strong attribute operations
        Superimposed operations.
        Operations on mutual sets.
        Selection on mutuals, this can be custom, see below.
        Mutual set selection: different ways to select mutual sets into a view
            When selecting, can put limits of how many mutual distance, and limit the mutual token types.
        Able to make macros. Macros made from push and pop of other operations. Only mutual operations allowed because they do no events
            Macros can be run by actions (not using script or remote, just set the macro id)
        Can register custom macros in the core, not by users, but by plugin. For instance macros to select via topology and area charges on mutual entanglements.

-------------------

    Search:
        Search results of sets should list its parent.
        New Search operations and search modifiers

-------------------

    Interfaces: see interfaces.md






