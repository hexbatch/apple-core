

Core:


    Types:
            token types can have live attributes that apply to all the tokens (but not the type itself)
                * changes for all tokens and can overwrite inherited on the tokens
                * live attributes put on the tokens can overwrite an attribute already there, by design or later action.
                * no limit to how many live attributes that overwrite the earlier one. They stack by when applied.
            need discussion about attributes able to overwrite their parents. If I have A inherits from B, and C inherits from B
                if a token has B, and I add a live of A, then that overwrites the B. However if I add C, then that does not overwrite B (B is not a child of A)
            scripts and remotes should have their storage as live token level attributes,
                but not sure how that works with the attribute value being a script and not the state for the script (remote too)
            Add Final status to forbid any usage of this type as a parent
            Add human status, default true, to selectively hide tokens made from this type in api calls if the human filter is on
            Can add parent to type as long as at least one attribute is readable
            Can add attribute to type or live when attribute is both readable and writable. Do not have to own attribute (this causes some changes in sketched out ntoes)


-------------------

    Live tokens:
        * When live attributes are added to a token,  record the user that added them.
        * Attribute values has a microsecond time stamp of when last written to, or turned on


-------------------

    Requirements:
        Now done via sets see filters.txt


-------------------

    Events:
        * Can send custom event, one that inherits from the custom even attribute, to any one token per api call to send event.

        * Can have a read event. Cycles prevented by new api mechanisms

        * Can have an event for applying or removing a live attribute, on the type level, for all tokens.
          * same event can be on the per token
          * same can be for live added or removed in a set context (the live cannot be seen outside that set)
          * can have one event for all three also


        * More events in interfaces

-------------------


    Set:
        Set tokens are seen as normal tokens unless in a set which has them as a child or link or parent.
            * "any token can make a set and still be a regular token"
        Sets that have a location set and a map bounds can only accept tokens that are in its bounds, or do not have a location set for them.
        Set parents are in the child as a token, just as the child is in the parent as a token
           Removing either breaks the parent child relationship
           Relationships for sets are still also defined by special defined attribute
        Can filter its content via one or more path boundaries
        Sets can have an attribute to mark them as a view


-------------------

    Set operations:

        set operations can use the human filter
        set operations use the pre-filter to decide to do the set operation
        get common tokens from a group of sets, put them in a new set. Can do opposite too: remove common tokens from groups
        Aggregation operations: Use group operations on selected attributes in a set to calculate one value which then is written to a target token attribute as a live attribute on the token.
        Aggregation operations take a set of tokens, can do operations on it to reduce this to a single value. The operation can be filtered
        Any api call can provide a token or attribute using an iterator from a set (current token), can filter attribute(s)  to use.

                set operations can have some logic now, optional set and filter to put in to decide to do the set operation in the api call.
                There has to be at least one token in the set that gets matched by the filter. This is not the filter to do the operation with, but to decide to do it or not.
        see new-set-operations for push and iterations


-------------------

    Mutual sets:
        Two or more sets that have one or more exact same tokens in their collections are connected together by these tokens, but not in a linked relationship
        These can be many sets bound together in different patterns and geometries. Mutually bound sets can also be connected via parent child relationships and links.
        Can select these relations into a set known as a view, which only contains mutually connected set systems (all the sets have to be directly or indirectly sharing the same tokens).



-------------------


    Mutual operations:
        Aggregation operations: can do aggregation operations on mutual sets. The operations can be written to a single attribute on a target token
            Agg op to combine ordered tokens in a set to json array
        Strong attribute operations
        Superimposed operations.
        Operations on mutual sets.
        Selection on mutuals, this can be custom, see below.
        Mutual set selection: different ways to select mutual sets into a view
            When selecting, can put limits of how many mutual distance, and limit the mutual token types.
        Able to make macros. Macros made from push and pop of other operations. Only mutual operations allowed because they do no events
            Macros can be run by actions (not using script or remote, just set the macro id)
        Can register custom macros in the core, not by users, but by plugin. For instance macros to select via topology and area charges on mutual entanglements.

-------------------

    Search:
        Search results of sets should list its parent.
        New Search operations and search modifiers.
        Searches can select on intersections of bounds (to select those that do or do not) for tokens inside the same set

-------------------

    Interfaces: see interfaces.md






