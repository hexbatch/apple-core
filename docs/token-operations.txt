token types
    create token type
    edit | retire


 token type properties:
    guid:
    owner_guid:
    parents:
    token appearance:
    attributes:
    bounds:

   token appearance
     name:
        symbol:
        primary_color:
        background_color:
        description:

   token type attribute:
      name:
      value_type: numeric, string
      min:
      max:
      enum:
      default:

       attribute limits on change can be : rate limits, times, area, whitelist of who can change this
       attributes can inherit from multiple older attributes, overwriting their values

        token attributes can contain large binary data , or large text data, there is an api to attach a file contents to an attribute

        attributes for rate limits too, the rate limits is how often a user, or users, can do a trade with this token type or set
           creating new tokens based on parent also has a rate limit
           To set different rate limits for specific users, then create a new token that inherits the older token and add new rate limits

       token type attributes can be constants (never set again) or variable (set by other token attributes or operations)
       attributes can have limits on how many times they can be set:
           attribute limits on change can be : rate limits, times, area

        attributes can have whitelists for allowed sibling attributes in both type and sets
        attributes can have whitelists for allowed users for inheriting from older attributes

        attributes have an owner

        the above says attributes, but attributes have types

        when a token type is made, it uses attribute types
        when a token is made, the attributes can take on dynamic values if not constant


------------------------------------------
 is a token set made out of a token type with the number of tokens, or is each token individually tracked
 if each token, that is a lot of resources to track distributed tokens when they all have the same values
 possible to create a token pointer or reference, and when a previously unused token is changed, then that token is stored then (like copy on write similar to strings)

 Then, that would mean each token set is a collection of token types only, and the optional quantity of each type
 this makes things a lot more complex, but does it?
 Token sets can contain references to unused tokens, or instantiated tokens
 How about instead of using copy on write, token sets can have the token type instead
 so two different types of token sets:
    one set has the number of token-types with the quantity of each
    another set has a collection of tokens
 Both sets are owned
 Sets can have boundaries and attributes
 Set operations also look at set attributes

 -----------------------------------
data types:
    action
    map bounds
    time bounds
    attributes
    token-type
    token-type-set
    token
    token-set


each data type has its own set of api operations

------------------------------------------

-------------------
actions can be registered that run javascript functions
 so maybe like this : actions only happen in the same token set, and if multiple actions of same guid, only one runs
    actions could run when attribute holding the action will be added to the token set, or when token set changed after that

    target attribute guid:
    target-from-state: string value or numeric range
    target-to-state: string value or numeric range
    md5 of script:
    script_state stored json and passed to script as an object, updated in the script
    script: input(target attribute a , token-set, script_state) : {array changed values in token set token id, new value, new script_state}
    action_location_entering: []
    action_location_leaving: []
    action_cron: []

but also need actions on new token instantiation for inherited attributes
     target attribute guid:
     recipient attribute :
     recipient token ;
     md5 of script:
     script_state stored json and passed to script as an object, updated in the script
     script: input(new token a) : {value to add to recipient,  new script_state}
     //the bounds of the attribute determine if this can be done
    action_location_entering: []  //the starting location of the token when its instantiated
    action_cron: [] //when the location is instantiated

so, to charge for the token use, include attribute that has this action as its value

Scripts that are run not able to call the api, so the passed in values is the object copy of the thing only, and can be altered by the script without api changing

rate limiting is an action, so can be the permissions for creation using the token as a parent or ancestor


actions can run on boundary set on the attribute, cron times make it run, entering or exiting areas: see location_entering, location_leaving
-------------------

 attribute:
    name:
    owner-guid:
    bounds:
        map:
            names: array
        time:
           names: array
       allowed_siblings:
           guid array
       allowed_descendants: guid array
       allowed_attribute_owners: guid array
       allowed_changers: guid array //for letting others change this value


        --- note: for the whitelists and allowed, if empty then everyone can do/use/alter
        --- a descendant inherits the whitelists and can change it , but any rates and token instantiation still works for the parents

    value:
        value_type: numeric, string,json, markdown, binary, action
                --- note:
                    attribute values can be a number, string, json, markdown, binary (image , pdf only)
                    string specific types can be :
                        iso date time, color, url, email, social account , phone, javascript, any
                    number is any numeric value
        min: (numeric only)
        max: (numeric only)
        enum: (string only)
        default:
    action:
        see above action, there are some extra fields here, each attribute can only have one action (of any type)

each instantiated attribute can only have one value
instantiated attributes have the live value, if an attribute is only using the default, then the current value is not recorded (values are recorded when value set to other than default)


--------------------------
a token bounds is the sum of its attribute bounds, but action attributes are not used for this
tokens have some default attributes.
tokens are just attribute sets what have ownership?


>   !--------------------
attributes can adjust other attribute values, but  only if on the whitelist, see allowed_changers

!!     ~~~~

----------------------

token group
  token_type:
  count:
  attribute_data: [{attribute_name: value}]


token_set:
    token_types:
    owner_guid:

set operations:
    combine: A source B source  C pattern D destination
    divide: sets A source B pattern C destinations
    create set: => empty set
    delete set: A removes a set
    list_user => C pattern(optional) , returns set
    populate_set => T type, D destination
    edit attribute => attribute name, attribute value , A source

user: create user guid, delete user guid, list user guids, edit user

user: guid , which is normal but can be set to something else for easy tracking when testing
             user details is handled in the next layer

Boundary operations
 create|edit|delete map bounds

 map bounds:
    name:
    polygon array:

 create|edit|delete cron bounds

 time bounds:
    name:
    cron:
    period_length:
    start:
    stop:


 tokens can have no value for trade, but set boundaries
 tokens can have attributes that they are usable for trade
 inventory is a type of token with attributes to describe it: so managing inventory is just using the regular token management api; however wrapper api to help with that




